"use strict";
const Voucher = require("../models/voucher.model");
const { BadRequestError, NotFoundError } = require("../core/error.response");
const voucherModel = require("../models/voucher.model");

class VoucherService {
  // T·∫°o voucher m·ªõi
  static async createVoucher(payload) {
    if (
      !payload.voucher_name ||
      !payload.voucher_description ||
      !payload.voucher_start_date ||
      !payload.voucher_end_date ||
      !payload.voucher_method ||
      !payload.voucher_value ||
      !payload.voucher_max_uses ||
      !payload.voucher_max_uses_per_user ||
      !payload.voucher_min_order_value ||
      !payload.voucher_code
    ) {
      throw new BadRequestError("Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc!");
    }

    try {
      // ƒê·∫£m b·∫£o voucher_code l√† chu·ªói h·ª£p l·ªá
      if (typeof payload.voucher_code !== "string" || payload.voucher_code.trim() === "") {
        throw new BadRequestError("M√£ voucher kh√¥ng h·ª£p l·ªá!");
      }
      // Ki·ªÉm tra xem voucher_code ƒë√£ t·ªìn t·∫°i ch∆∞a
      const existingVoucher = await voucherModel.findOne({ voucher_code: payload.voucher_code });
      // T·∫°o voucher m·ªõi
      const voucher = await voucherModel.create(payload);
      return voucher;
    } catch (error) {
      throw error;
    }
  }

  // L·∫•y danh s√°ch t·∫•t c·∫£ voucher
  static async getAllVouchers() {
    return await voucherModel.find();
  }

  // L·∫•y voucher theo ID
  static async getVoucherById(id) {
    const voucher = await voucherModel.findById(id);
    if (!voucher) throw new NotFoundError("Voucher kh√¥ng t·ªìn t·∫°i!");
    return voucher;
  }

  // C·∫≠p nh·∫≠t voucher theo ID
  static async updateVoucher(id, payload) {
    const updatedVoucher = await voucherModel.findByIdAndUpdate(id, payload, { new: true });
    if (!updatedVoucher) throw new NotFoundError("Voucher kh√¥ng t·ªìn t·∫°i!");
    return updatedVoucher;
  }

  // X√≥a voucher theo ID
  static async deleteVoucher(id) {
    const voucher = await voucherModel.findByIdAndDelete(id);
    if (!voucher) throw new NotFoundError("Voucher kh√¥ng t·ªìn t·∫°i!");
    return voucher;
  }

  // üîπ T√¨m ki·∫øm voucher theo t√™n
  static async searchVoucherByName(name) {
    const vouchers = await voucherModel.find({
      voucher_name: { $regex: new RegExp(name, "i") }
    });
    if (!vouchers.length) throw new NotFoundError("Kh√¥ng t√¨m th·∫•y voucher ph√π h·ª£p!");
    return vouchers;
  }
}

module.exports = VoucherService;
